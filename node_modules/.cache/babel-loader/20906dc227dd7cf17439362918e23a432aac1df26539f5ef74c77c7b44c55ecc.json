{"ast":null,"code":"import { encodeQueryParams } from \"serialize-query-params\";\nimport { decodedParamCache } from \"./decodedParamCache\";\nimport { extendParamConfigForKeys } from \"./inheritedParams\";\nimport { getLatestDecodedValues } from \"./latestValues\";\nimport { memoSearchStringToObject } from \"./memoSearchStringToObject\";\nimport { removeDefaults } from \"./removeDefaults\";\nimport { applyUrlNames } from \"./urlName\";\nfunction getUpdatedSearchString(_ref) {\n  let {\n    changes,\n    updateType,\n    currentSearchString,\n    paramConfigMap: baseParamConfigMap,\n    options\n  } = _ref;\n  const {\n    searchStringToObject,\n    objectToSearchString\n  } = options;\n  if (updateType == null) updateType = options.updateType;\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(searchStringToObject, currentSearchString);\n  const paramConfigMap = extendParamConfigForKeys(baseParamConfigMap, Object.keys(changes), options.params);\n  let changesToUse;\n  if (typeof changes === \"function\") {\n    const latestValues = getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache);\n    changesToUse = changes(latestValues);\n  } else {\n    changesToUse = changes;\n  }\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n  let newSearchString;\n  if (updateType === \"push\" || updateType === \"replace\") {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges\n    });\n  }\n  if ((newSearchString == null ? void 0 : newSearchString.length) && newSearchString[0] !== \"?\") {\n    newSearchString = `?${newSearchString}`;\n  }\n  return newSearchString != null ? newSearchString : \"\";\n}\nfunction updateSearchString(_ref2) {\n  let {\n    searchString,\n    adapter,\n    navigate,\n    updateType\n  } = _ref2;\n  const currentLocation = adapter.location;\n  const newLocation = {\n    ...currentLocation,\n    search: searchString\n  };\n  if (navigate) {\n    if (typeof updateType === \"string\" && updateType.startsWith(\"replace\")) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\nconst immediateTask = task => task();\nconst timeoutTask = task => setTimeout(() => task(), 0);\nconst updateQueue = [];\nfunction enqueueUpdate(args) {\n  let {\n    immediate\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n      let searchString;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate = i === 0 ? updates[i] : {\n          ...updates[i],\n          currentSearchString: searchString\n        };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n      if (args.options.skipUpdateWhenNoChange && searchString === initialSearchString) {\n        return;\n      }\n      updateSearchString({\n        searchString: searchString != null ? searchString : \"\",\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType\n      });\n    });\n  }\n}\nexport { enqueueUpdate, getUpdatedSearchString, updateSearchString };","map":{"version":3,"names":["encodeQueryParams","decodedParamCache","extendParamConfigForKeys","getLatestDecodedValues","memoSearchStringToObject","removeDefaults","applyUrlNames","getUpdatedSearchString","_ref","changes","updateType","currentSearchString","paramConfigMap","baseParamConfigMap","options","searchStringToObject","objectToSearchString","encodedChanges","parsedParams","Object","keys","params","changesToUse","latestValues","removeDefaultsFromUrl","newSearchString","length","updateSearchString","_ref2","searchString","adapter","navigate","currentLocation","location","newLocation","search","startsWith","replace","push","immediateTask","task","timeoutTask","setTimeout","updateQueue","enqueueUpdate","args","immediate","arguments","undefined","scheduleTask","updates","slice","initialSearchString","i","modifiedUpdate","skipUpdateWhenNoChange"],"sources":["/home/remmy/Documents/Development/code/phase-5/CodeOverflow/frontend/node_modules/use-query-params/src/updateSearchString.ts"],"sourcesContent":["import {\n  DecodedValueMap,\n  encodeQueryParams,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport { extendParamConfigForKeys } from './inheritedParams';\nimport { getLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { QueryParamOptionsWithRequired } from './options';\nimport { removeDefaults } from './removeDefaults';\nimport { PartialLocation, QueryParamAdapter, UrlUpdateType } from './types';\nimport { applyUrlNames } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\n/**\n * Given a ?foo=1&bar=2 and { bar: 3, baz: true } produce ?foo=1&bar=3&baz=1\n * or similar, depending on updateType. The result will be prefixed with \"?\"\n * or just be the empty string.\n */\nexport function getUpdatedSearchString({\n  changes,\n  updateType,\n  currentSearchString,\n  paramConfigMap: baseParamConfigMap,\n  options,\n}: {\n  changes: ChangesType<DecodedValueMap<any>>;\n  updateType?: UrlUpdateType;\n  currentSearchString: string;\n  paramConfigMap: QueryParamConfigMap;\n  options: QueryParamOptionsWithRequired;\n}): string {\n  const { searchStringToObject, objectToSearchString } = options;\n  if (updateType == null) updateType = options.updateType;\n\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(\n    searchStringToObject,\n    currentSearchString\n  );\n\n  // see if we have unconfigured params in the changes that we can\n  // inherit to expand our config map instead of just using strings\n  const paramConfigMap = extendParamConfigForKeys(\n    baseParamConfigMap,\n    Object.keys(changes),\n    options.params\n  );\n\n  // update changes prior to encoding to handle removing defaults\n  // getting latest values when functional update\n  let changesToUse: Partial<DecodedValueMap<any>>;\n\n  // functional updates here get the latest values\n  if (typeof changes === 'function') {\n    const latestValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n\n    changesToUse = (changes as Function)(latestValues);\n  } else {\n    // simple update here\n    changesToUse = changes;\n  }\n\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n\n  // remove defaults\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n\n  // interpret urlNames\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n\n  let newSearchString: string;\n  if (updateType === 'push' || updateType === 'replace') {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges,\n    });\n  }\n\n  if (newSearchString?.length && newSearchString[0] !== '?') {\n    (newSearchString as any) = `?${newSearchString}`;\n  }\n\n  return newSearchString ?? '';\n}\n\n/**\n * uses an adapter to update a location object and optionally\n * navigate based on the updateType\n */\nexport function updateSearchString({\n  searchString,\n  adapter,\n  navigate,\n  updateType,\n}: {\n  searchString: string;\n  adapter: QueryParamAdapter;\n  navigate: boolean;\n  updateType?: UrlUpdateType;\n}) {\n  const currentLocation = adapter.location;\n\n  // update the location and URL\n  const newLocation: PartialLocation = {\n    ...currentLocation,\n    search: searchString,\n  };\n\n  if (navigate) {\n    // be defensive about checking updateType since it is somewhat easy to\n    // accidentally pass a second argument to the setter.\n    if (typeof updateType === 'string' && updateType.startsWith('replace')) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\n\ntype UpdateArgs = Parameters<typeof getUpdatedSearchString>[0] & {\n  adapter: QueryParamAdapter;\n};\n\nconst immediateTask = (task: Function) => task();\nconst timeoutTask = (task: Function) => setTimeout(() => task(), 0);\n// alternative could be native `queueMicrotask`\n\nconst updateQueue: UpdateArgs[] = [];\n\n/**\n * support batching by enqueuing updates (if immediate is not true)\n */\nexport function enqueueUpdate(\n  args: UpdateArgs,\n  { immediate }: { immediate?: boolean } = {}\n) {\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n\n      let searchString: string | undefined;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate: UpdateArgs =\n          i === 0\n            ? updates[i]\n            : { ...updates[i], currentSearchString: searchString! };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n\n      // do not update unnecessarily #234\n      if (\n        args.options.skipUpdateWhenNoChange &&\n        searchString === initialSearchString\n      ) {\n        return;\n      }\n\n      updateSearchString({\n        searchString: searchString ?? '',\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType,\n      });\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}