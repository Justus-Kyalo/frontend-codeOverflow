{"ast":null,"code":"import shallowEqual from \"./shallowEqual\";\nfunction getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache) {\n  const decodedValues = {};\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n      if (paramConfig.equals && decodedParamCache.has(paramName, encodedValue)) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n      if (decodedValue !== void 0) {\n        decodedParamCache.set(paramName, encodedValue, decodedValue, paramConfig.decode);\n      }\n    }\n    if (decodedValue === void 0 && paramConfig.default !== void 0) {\n      decodedValue = paramConfig.default;\n    }\n    decodedValues[paramName] = decodedValue;\n  }\n  return decodedValues;\n}\nfunction makeStableGetLatestDecodedValues() {\n  let prevDecodedValues;\n  function stableGetLatest(parsedParams, paramConfigMap, decodedParamCache) {\n    const decodedValues = getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache);\n    if (prevDecodedValues != null && shallowEqual(prevDecodedValues, decodedValues)) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n  return stableGetLatest;\n}\nexport { getLatestDecodedValues, makeStableGetLatestDecodedValues };","map":{"version":3,"names":["shallowEqual","getLatestDecodedValues","parsedParams","paramConfigMap","decodedParamCache","decodedValues","paramNames","Object","keys","paramName","paramConfig","encodedValue","decodedValue","has","decode","get","equals","oldDecodedValue","set","default","makeStableGetLatestDecodedValues","prevDecodedValues","stableGetLatest"],"sources":["/home/john/development/frontend/node_modules/use-query-params/src/latestValues.ts"],"sourcesContent":["import {\n  DecodedValueMap,\n  EncodedQuery,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { DecodedParamCache } from './decodedParamCache';\nimport shallowEqual from './shallowEqual';\n\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nexport function getLatestDecodedValues<QPCMap extends QueryParamConfigMap>(\n  parsedParams: EncodedQuery,\n  paramConfigMap: QPCMap,\n  decodedParamCache: DecodedParamCache\n) {\n  const decodedValues: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    // do we have a new encoded value?\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n\n    // if we have a new encoded value, re-decode. otherwise reuse cache\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n\n      // check if we had a cached value for this encoded value but a different encoder\n      // (sometimes people inline decode functions, e.g. withDefault...)\n      // AND we had a different equals check than ===\n      if (\n        paramConfig.equals &&\n        decodedParamCache.has(paramName, encodedValue)\n      ) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n\n      // do not cache undefined values\n      if (decodedValue !== undefined) {\n        decodedParamCache.set(\n          paramName,\n          encodedValue,\n          decodedValue,\n          paramConfig.decode\n        );\n      }\n    }\n\n    // in case the decode function didn't interpret `default` for some reason,\n    // we can interpret it here as a backup\n    if (decodedValue === undefined && paramConfig.default !== undefined) {\n      decodedValue = paramConfig.default;\n    }\n\n    decodedValues[paramName as keyof QPCMap] = decodedValue;\n  }\n\n  return decodedValues as DecodedValueMap<QPCMap>;\n}\n\n/**\n * Wrap get latest so we use the same exact object if the current\n * values are shallow equal to the previous.\n */\nexport function makeStableGetLatestDecodedValues() {\n  let prevDecodedValues: DecodedValueMap<any> | undefined;\n\n  function stableGetLatest<QPCMap extends QueryParamConfigMap>(\n    parsedParams: EncodedQuery,\n    paramConfigMap: QPCMap,\n    decodedParamCache: DecodedParamCache\n  ) {\n    const decodedValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n    if (\n      prevDecodedValues != null &&\n      shallowEqual(prevDecodedValues, decodedValues)\n    ) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n\n  return stableGetLatest;\n}\n"],"mappings":"AAMA,OAAOA,YAAA,MAAkB;AAMlB,SAASC,uBACdC,YAAA,EACAC,cAAA,EACAC,iBAAA,EACA;EACA,MAAMC,aAAA,GAAkD,CAAC;EAIzD,MAAMC,UAAA,GAAaC,MAAA,CAAOC,IAAA,CAAKL,cAAc;EAC7C,WAAWM,SAAA,IAAaH,UAAA,EAAY;IAElC,MAAMI,WAAA,GAAcP,cAAA,CAAeM,SAAA;IACnC,MAAME,YAAA,GAAeT,YAAA,CAAaO,SAAA;IAGlC,IAAIG,YAAA;IACJ,IAAIR,iBAAA,CAAkBS,GAAA,CAAIJ,SAAA,EAAWE,YAAA,EAAcD,WAAA,CAAYI,MAAM,GAAG;MACtEF,YAAA,GAAeR,iBAAA,CAAkBW,GAAA,CAAIN,SAAS;IAChD,OAAO;MACLG,YAAA,GAAeF,WAAA,CAAYI,MAAA,CAAOH,YAAY;MAK9C,IACED,WAAA,CAAYM,MAAA,IACZZ,iBAAA,CAAkBS,GAAA,CAAIJ,SAAA,EAAWE,YAAY,GAC7C;QACA,MAAMM,eAAA,GAAkBb,iBAAA,CAAkBW,GAAA,CAAIN,SAAS;QACvD,IAAIC,WAAA,CAAYM,MAAA,CAAOJ,YAAA,EAAcK,eAAe,GAAG;UACrDL,YAAA,GAAeK,eAAA;QACjB;MACF;MAGA,IAAIL,YAAA,KAAiB,QAAW;QAC9BR,iBAAA,CAAkBc,GAAA,CAChBT,SAAA,EACAE,YAAA,EACAC,YAAA,EACAF,WAAA,CAAYI,MAAA,CACd;MACF;IACF;IAIA,IAAIF,YAAA,KAAiB,UAAaF,WAAA,CAAYS,OAAA,KAAY,QAAW;MACnEP,YAAA,GAAeF,WAAA,CAAYS,OAAA;IAC7B;IAEAd,aAAA,CAAcI,SAAA,IAA6BG,YAAA;EAC7C;EAEA,OAAOP,aAAA;AACT;AAMO,SAASe,iCAAA,EAAmC;EACjD,IAAIC,iBAAA;EAEJ,SAASC,gBACPpB,YAAA,EACAC,cAAA,EACAC,iBAAA,EACA;IACA,MAAMC,aAAA,GAAgBJ,sBAAA,CACpBC,YAAA,EACAC,cAAA,EACAC,iBAAA,CACF;IACA,IACEiB,iBAAA,IAAqB,QACrBrB,YAAA,CAAaqB,iBAAA,EAAmBhB,aAAa,GAC7C;MACA,OAAOgB,iBAAA;IACT;IACAA,iBAAA,GAAoBhB,aAAA;IACpB,OAAOA,aAAA;EACT;EAEA,OAAOiB,eAAA;AACT"},"metadata":{},"sourceType":"module","externalDependencies":[]}