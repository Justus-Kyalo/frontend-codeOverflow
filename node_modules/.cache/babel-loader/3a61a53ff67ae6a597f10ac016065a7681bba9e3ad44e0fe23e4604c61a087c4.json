{"ast":null,"code":"import { useEffect, useMemo, useRef, useState } from \"react\";\nimport { StringParam } from \"serialize-query-params\";\nimport { decodedParamCache } from \"./decodedParamCache\";\nimport { extendParamConfigForKeys, convertInheritedParamStringsToParams } from \"./inheritedParams\";\nimport { makeStableGetLatestDecodedValues } from \"./latestValues\";\nimport { memoSearchStringToObject } from \"./memoSearchStringToObject\";\nimport { mergeOptions } from \"./options\";\nimport { useQueryParamContext } from \"./QueryParamProvider\";\nimport { enqueueUpdate } from \"./updateSearchString\";\nimport { serializeUrlNameMap } from \"./urlName\";\nfunction useQueryParams(arg1, arg2) {\n  const {\n    adapter,\n    options: contextOptions\n  } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n  const {\n    paramConfigMap: paramConfigMapWithInherit,\n    options\n  } = parseArguments(arg1, arg2);\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n  let paramConfigMap = convertInheritedParamStringsToParams(paramConfigMapWithInherit, mergedOptions);\n  const parsedParams = memoSearchStringToObject(mergedOptions.searchStringToObject, adapter.location.search, serializeUrlNameMap(paramConfigMap));\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(paramConfigMap, Object.keys(parsedParams), mergedOptions.params, StringParam);\n  }\n  const decodedValues = stableGetLatest(parsedParams, paramConfigMap, decodedParamCache);\n  const paramKeyString = Object.keys(paramConfigMap).join(\"\\0\");\n  useEffect(() => {\n    const paramNames = paramKeyString.split(\"\\0\");\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions\n  };\n  const callbackDependenciesRef = useRef(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n  const [setQuery] = useState(() => {\n    const setQuery2 = (changes, updateType) => {\n      const {\n        adapter: adapter2,\n        paramConfigMap: paramConfigMap2,\n        options: options2\n      } = callbackDependenciesRef.current;\n      if (updateType == null) updateType = options2.updateType;\n      enqueueUpdate({\n        changes,\n        updateType,\n        currentSearchString: adapter2.location.search,\n        paramConfigMap: paramConfigMap2,\n        options: options2,\n        adapter: adapter2\n      }, {\n        immediate: !options2.enableBatching\n      });\n    };\n    return setQuery2;\n  });\n  return [decodedValues, setQuery];\n}\nvar useQueryParams_default = useQueryParams;\nfunction parseArguments(arg1, arg2) {\n  let paramConfigMap;\n  let options;\n  if (arg1 === void 0) {\n    paramConfigMap = {};\n    options = arg2;\n  } else if (Array.isArray(arg1)) {\n    paramConfigMap = Object.fromEntries(arg1.map(key => [key, \"inherit\"]));\n    options = arg2;\n  } else {\n    paramConfigMap = arg1;\n    options = arg2;\n  }\n  return {\n    paramConfigMap,\n    options\n  };\n}\nexport { useQueryParams_default as default, useQueryParams };","map":{"version":3,"names":["useEffect","useMemo","useRef","useState","StringParam","decodedParamCache","extendParamConfigForKeys","convertInheritedParamStringsToParams","makeStableGetLatestDecodedValues","memoSearchStringToObject","mergeOptions","useQueryParamContext","enqueueUpdate","serializeUrlNameMap","useQueryParams","arg1","arg2","adapter","options","contextOptions","stableGetLatest","paramConfigMap","paramConfigMapWithInherit","parseArguments","mergedOptions","parsedParams","searchStringToObject","location","search","includeAllParams","Object","keys","params","decodedValues","paramKeyString","join","paramNames","split","registerParams","unregisterParams","callbackDependencies","callbackDependenciesRef","current","setQuery","setQuery2","changes","updateType","adapter2","paramConfigMap2","options2","currentSearchString","immediate","enableBatching","useQueryParams_default","Array","isArray","fromEntries","map","key"],"sources":["/home/remmy/Documents/Development/code/phase-5/CodeOverflow/frontend/node_modules/use-query-params/src/useQueryParams.ts"],"sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DecodedValueMap,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport {\n  extendParamConfigForKeys,\n  convertInheritedParamStringsToParams,\n} from './inheritedParams';\nimport { makeStableGetLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { mergeOptions, QueryParamOptions } from './options';\nimport { useQueryParamContext } from './QueryParamProvider';\nimport {\n  QueryParamConfigMapWithInherit,\n  SetQuery,\n  UrlUpdateType,\n} from './types';\nimport { enqueueUpdate } from './updateSearchString';\nimport { serializeUrlNameMap } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\ntype UseQueryParamsResult<QPCMap extends QueryParamConfigMap> = [\n  DecodedValueMap<QPCMap>,\n  SetQuery<QPCMap>\n];\ntype ExpandInherits<QPCMap extends QueryParamConfigMapWithInherit> = {\n  [ParamName in keyof QPCMap]: QPCMap[ParamName] extends string\n    ? typeof StringParam\n    : QPCMap[ParamName] extends QueryParamConfig<any>\n    ? QPCMap[ParamName]\n    : never;\n};\n\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMap = QueryParamConfigMap\n>(): UseQueryParamsResult<QPCMap>;\nexport function useQueryParams<QPCMap extends QueryParamConfigMapWithInherit>(\n  names: string[],\n  options?: QueryParamOptions\n): UseQueryParamsResult<ExpandInherits<QPCMap>>;\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMapWithInherit,\n  OutputQPCMap extends QueryParamConfigMap = ExpandInherits<QPCMap>\n>(\n  paramConfigMap: QPCMap,\n  options?: QueryParamOptions\n): UseQueryParamsResult<OutputQPCMap>;\nexport function useQueryParams(\n  arg1?: string[] | QueryParamConfigMapWithInherit,\n  arg2?: QueryParamConfig<any> | QueryParamOptions\n): UseQueryParamsResult<any> {\n  const { adapter, options: contextOptions } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n\n  // intepret the overloaded arguments\n  const { paramConfigMap: paramConfigMapWithInherit, options } = parseArguments(\n    arg1,\n    arg2\n  );\n\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n\n  // interpret params that were configured up the chain\n  let paramConfigMap = convertInheritedParamStringsToParams(\n    paramConfigMapWithInherit,\n    mergedOptions\n  );\n\n  // what is the current stringified value?\n  const parsedParams = memoSearchStringToObject(\n    mergedOptions.searchStringToObject,\n    adapter.location.search,\n    serializeUrlNameMap(paramConfigMap) // note we serialize for memo purposes\n  );\n\n  // do we want to include all params from the URL even if not configured?\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(\n      paramConfigMap,\n      Object.keys(parsedParams),\n      mergedOptions.params,\n      StringParam\n    );\n  }\n\n  // run decode on each key\n  const decodedValues = stableGetLatest(\n    parsedParams,\n    paramConfigMap,\n    decodedParamCache\n  );\n\n  // clear out unused values in cache\n  // use string for relatively stable effect dependency\n  const paramKeyString = Object.keys(paramConfigMap).join('\\0');\n  useEffect(() => {\n    const paramNames = paramKeyString.split('\\0');\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n\n  // create a setter for updating multiple query params at once\n  // use a ref for callback dependencies so we don't generate a new one unnecessarily\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions,\n  };\n  const callbackDependenciesRef =\n    useRef<typeof callbackDependencies>(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n\n  // create callback with stable identity\n  const [setQuery] = useState(() => {\n    const setQuery = (\n      changes: ChangesType<DecodedValueMap<any>>,\n      updateType?: UrlUpdateType\n    ) => {\n      // read from a ref so we don't generate new setters each time any change\n      const { adapter, paramConfigMap, options } =\n        callbackDependenciesRef.current!;\n      if (updateType == null) updateType = options.updateType;\n\n      enqueueUpdate(\n        {\n          changes,\n          updateType,\n          currentSearchString: adapter.location.search,\n          paramConfigMap,\n          options,\n          adapter,\n        },\n        { immediate: !options.enableBatching }\n      );\n    };\n\n    return setQuery;\n  });\n\n  return [decodedValues, setQuery];\n}\n\nexport default useQueryParams;\n\nfunction parseArguments(\n  arg1: string[] | QueryParamConfigMapWithInherit | undefined,\n  arg2: QueryParamConfig<any> | QueryParamOptions | undefined\n): {\n  paramConfigMap: QueryParamConfigMapWithInherit;\n  options: QueryParamOptions | undefined;\n} {\n  let paramConfigMap: QueryParamConfigMapWithInherit;\n  let options: QueryParamOptions | undefined;\n\n  if (arg1 === undefined) {\n    // useQueryParams()\n    paramConfigMap = {};\n    options = arg2 as QueryParamOptions | undefined;\n  } else if (Array.isArray(arg1)) {\n    // useQueryParams(['geo', 'other'])\n    // useQueryParams(['geo', 'other'], options)\n    paramConfigMap = Object.fromEntries(\n      arg1.map((key) => [key, 'inherit' as const])\n    );\n    options = arg2 as QueryParamOptions | undefined;\n  } else {\n    // useQueryParams({ geo: NumberParam })\n    // useQueryParams({ geo: NumberParam }, options)\n    paramConfigMap = arg1;\n    options = arg2 as QueryParamOptions | undefined;\n  }\n\n  return { paramConfigMap, options };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}