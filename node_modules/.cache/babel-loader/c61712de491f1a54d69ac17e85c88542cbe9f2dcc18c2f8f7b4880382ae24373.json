{"ast":null,"code":"function serializeUrlNameMap(paramConfigMap) {\n  let urlNameMapParts;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];else urlNameMapParts.push(part);\n    }\n  }\n  return urlNameMapParts ? urlNameMapParts.join(\"\\n\") : void 0;\n}\nfunction deserializeUrlNameMap(urlNameMapStr) {\n  if (!urlNameMapStr) return void 0;\n  return Object.fromEntries(urlNameMapStr.split(\"\\n\").map(part => part.split(\"\\0\")));\n}\nfunction applyUrlNames(encodedValues, paramConfigMap) {\n  var _a;\n  let newEncodedValues = {};\n  for (const paramName in encodedValues) {\n    if (((_a = paramConfigMap[paramName]) == null ? void 0 : _a.urlName) != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName] = encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n  return newEncodedValues;\n}\nexport { applyUrlNames, deserializeUrlNameMap, serializeUrlNameMap };","map":{"version":3,"names":["serializeUrlNameMap","paramConfigMap","urlNameMapParts","paramName","urlName","part","push","join","deserializeUrlNameMap","urlNameMapStr","Object","fromEntries","split","map","applyUrlNames","encodedValues","_a","newEncodedValues"],"sources":["/home/remmy/Documents/Development/code/phase-5/CodeOverflow/frontend/node_modules/use-query-params/src/urlName.ts"],"sourcesContent":["import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Create an alias mapping using the optional `urlName` property on params\n */\nexport function serializeUrlNameMap(\n  paramConfigMap: QueryParamConfigMap\n): string | undefined {\n  let urlNameMapParts: string[] | undefined;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];\n      else urlNameMapParts.push(part);\n    }\n  }\n\n  return urlNameMapParts ? urlNameMapParts.join('\\n') : undefined;\n}\n\n/**\n * Converts the stringified alias/urlName map back into an object\n */\nexport function deserializeUrlNameMap(\n  urlNameMapStr: string | undefined\n): Record<string, string> | undefined {\n  if (!urlNameMapStr) return undefined;\n\n  return Object.fromEntries(\n    urlNameMapStr.split('\\n').map((part) => part.split('\\0'))\n  );\n}\n\n/**\n * converts { searchString: 'foo'} to { q: 'foo'} if the searchString\n * is configured to have \"q\" as its urlName.\n */\nexport function applyUrlNames(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  let newEncodedValues: Partial<EncodedValueMap<any>> = {};\n  for (const paramName in encodedValues) {\n    if (paramConfigMap[paramName]?.urlName != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName!] =\n        encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n\n  return newEncodedValues;\n}\n"],"mappings":"AAKO,SAASA,oBACdC,cAAA,EACoB;EACpB,IAAIC,eAAA;EACJ,WAAWC,SAAA,IAAaF,cAAA,EAAgB;IACtC,IAAIA,cAAA,CAAeE,SAAA,EAAWC,OAAA,EAAS;MACrC,MAAMA,OAAA,GAAUH,cAAA,CAAeE,SAAA,EAAWC,OAAA;MAC1C,MAAMC,IAAA,GAAO,GAAGD,OAAA,KAAYD,SAAA;MAC5B,IAAI,CAACD,eAAA,EAAiBA,eAAA,GAAkB,CAACG,IAAI,OACxCH,eAAA,CAAgBI,IAAA,CAAKD,IAAI;IAChC;EACF;EAEA,OAAOH,eAAA,GAAkBA,eAAA,CAAgBK,IAAA,CAAK,IAAI,IAAI;AACxD;AAKO,SAASC,sBACdC,aAAA,EACoC;EACpC,IAAI,CAACA,aAAA,EAAe,OAAO;EAE3B,OAAOC,MAAA,CAAOC,WAAA,CACZF,aAAA,CAAcG,KAAA,CAAM,IAAI,EAAEC,GAAA,CAAKR,IAAA,IAASA,IAAA,CAAKO,KAAA,CAAM,IAAI,CAAC,EAC1D;AACF;AAMO,SAASE,cACdC,aAAA,EACAd,cAAA,EACA;EAzCF,IAAAe,EAAA;EA0CE,IAAIC,gBAAA,GAAkD,CAAC;EACvD,WAAWd,SAAA,IAAaY,aAAA,EAAe;IACrC,MAAIC,EAAA,GAAAf,cAAA,CAAeE,SAAA,MAAf,gBAAAa,EAAA,CAA2BZ,OAAA,KAAW,MAAM;MAC9Ca,gBAAA,CAAiBhB,cAAA,CAAeE,SAAA,EAAWC,OAAA,IACzCW,aAAA,CAAcZ,SAAA;IAClB,OAAO;MACLc,gBAAA,CAAiBd,SAAA,IAAaY,aAAA,CAAcZ,SAAA;IAC9C;EACF;EAEA,OAAOc,gBAAA;AACT"},"metadata":{},"sourceType":"module","externalDependencies":[]}